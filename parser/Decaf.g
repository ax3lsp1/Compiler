parser grammar Decaf;options {    tokenVocab=DecafLexer;}@header {package compiler.parser;import java.util.concurrent.ConcurrentLinkedQueue;}@members {ConcurrentLinkedQueue<String> lista = new ConcurrentLinkedQueue<String>();	public void Imprimir(String elementos){			System.out.println(elementos);	}		public ConcurrentLinkedQueue<String> getOutPut() {        return lista;    }		}program     :	CLASS PROGRAM LLAVEI field_decl* method_decl* LLAVED {Imprimir("Program Declaration");};field_decl	:	type (decl_list) (COMA (decl_list))* PUNTOCOMA {Imprimir("field_decl");}; decl_list	:	ID | ID CORCHETEI int_literal CORCHETED {Imprimir("decl_list");};method_decl	:	type ID PARENTESISI (type ID) ((COMA (type ID))*)? PARENTESISD block {Imprimir("method_decl");};------------------------method_type :   type {Imprimir("method_type: type");} | VOID {Imprimir("method_type: VOID");};block 		: 	LLAVEI block_decl* statement* LLAVED {Imprimir("block");};block_decl	:	var_decl | statement {Imprimir("block_decl");};var_decl 	: 	type ID (COMA ID)* PUNTOCOMA {Imprimir("var_decl");};type 		: 	INT {Imprimir("type int");} | BOOLEAN {Imprimir("type boolean");};statement : location assign_op expr PUNTOCOMA {Imprimir("statement asign");} 			| method_call PUNTOCOMA {Imprimir("statement method_call");} 			| IF PARENTESISI expr PARENTESISD block (ELSE block)? {Imprimir("statement if block");} 			| FOR ID IGUAL expr COMA expr block {Imprimir("statement for block");} 			| RETURN expr? PUNTOCOMA {Imprimir("statement return");} 			| BREAK PUNTOCOMA {Imprimir("statement break");} 			| CONTINUE PUNTOCOMA {Imprimir("statement continue");}			| block {Imprimir("statement block");};	assign_op 	: 	IGUAL {Imprimir("assign_op =");}				| MENOSIGUAL {Imprimir("assign_op +=");}				| MASIGUAL {Imprimir("assign_op -=");};method_call : 	method_name PARENTESISI (expr (COMA expr)*)? PARENTESISD {Imprimir("method_call");}				| CALLOUT PARENTESISI string_literal (COMA callout_arg)* PARENTESISD {Imprimir("callout");};method_name : 	ID {Imprimir("method_name");};location 	: 	ID {Imprimir("variable id");} 				| ID CORCHETEI expr CORCHETED {Imprimir("id arreglo");};expr 		: 	location 				| method_call 				| literal 				| bin_op {Imprimir("expr");};				callout_arg : expr | string_literal {Imprimir("callout_arg");};string_literal : CHAIN {Imprimir("string_literal");};bin_op 		: and_logico (OR and_logico)* {Imprimir("bin_op");};and_logico 	: comparacion (AND comparacion)* {Imprimir("and_logico");};comparacion : suma (MENORQUE suma | MAYORQUE suma | MENORIGUAL suma | MAYORIGUAL suma)* {Imprimir("comparacion");};suma 		: multiplica (MAS multiplica | MENOS multiplica)* {Imprimir("multiplica (MAS multiplica | MENOS multiplica)*");};multiplica 	: expr_prim (MULTIPLICACION expr_prim | DIVISION expr_prim | MODULO expr_prim)* {Imprimir("expr_prim (MULTIPLICACION expr_prim | DIVISION expr_prim | MODULO expr_prim)*");};expr_prim 	: MENOS expr | NEGADO expr | PARENTESISD expr PARENTESISI {Imprimir("MENOS expr | NEGADO expr | PARENTESISD expr PARENTESISI");};literal 	: int_literal | char_literal | bool_literal {Imprimir("int_literal | char_literal | bool_literal");};int_literal : NUMEROS {Imprimir("NUMEROS");};char_literal: CARACTER {Imprimir("CARACTER");};bool_literal: TRUE | FALSE {Imprimir("TRUE | FALSE");};