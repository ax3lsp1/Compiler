parser grammar Decaf;options {    tokenVocab=DecafLexer;}@header {package compiler.parser;import java.util.concurrent.ConcurrentLinkedQueue;}@members {ConcurrentLinkedQueue<String> lista = new ConcurrentLinkedQueue<String>();	public void Imprimir(String elementos){			System.out.println(elementos);	}		public ConcurrentLinkedQueue<String> getOutPut() {        return lista;    }		}program     :	CLASS PROGRAM LLAVEI field_decl* method_decl* LLAVED {lista.add("Program Declaration");};field_decl	:	type (decl_list) (COMA (decl_list))* PUNTOCOMA {lista.add("field_decl");}; decl_list	:	ID | ID CORCHETEI int_literal CORCHETED {lista.add("decl_list");};method_decl	:	type ID PARENTESISI (type ID) ((COMA (type ID))*)? PARENTESISD block {lista.add("method_decl");};------------------------method_type :   type {lista.add("method_type: type");}; block 		: 	LLAVEI block_decl* statement* LLAVED {lista.add("block");};block_decl	:	var_decl | statement {lista.add("block_decl");};var_decl 	: 	type ID (COMA ID)* PUNTOCOMA {lista.add("var_decl");};type 		: 	INT {lista.add("type int");} | BOOLEAN {lista.add("type boolean");} | VOID {lista.add("method_type: VOID");};statement : location assign_op expr PUNTOCOMA {lista.add("statement asign");} 			| method_call PUNTOCOMA {lista.add("statement method_call");} 			| IF PARENTESISI expr PARENTESISD block (ELSE block)? {lista.add("statement if block");} 			| FOR ID IGUAL expr COMA expr block {lista.add("statement for block");} 			| RETURN expr? PUNTOCOMA {lista.add("statement return");} 			| BREAK PUNTOCOMA {lista.add("statement break");} 			| CONTINUE PUNTOCOMA {lista.add("statement continue");}			| block {lista.add("statement block");};	assign_op 	: 	IGUAL {lista.add("assign_op =");}				| MENOSIGUAL {lista.add("assign_op +=");}				| MASIGUAL {lista.add("assign_op -=");};method_call : 	method_name PARENTESISI (expr (COMA expr)*)? PARENTESISD {lista.add("method_call");}				| CALLOUT PARENTESISI string_literal (COMA callout_arg)* PARENTESISD {lista.add("callout");};method_name : 	ID {lista.add("method_name");};location 	: 	ID {lista.add("variable id");} 				| ID CORCHETEI expr CORCHETED {lista.add("id arreglo");};expr 		: 	location 				| method_call 				| literal 				| bin_op {lista.add("expr");};				callout_arg : expr | string_literal {lista.add("callout_arg");};string_literal : CHAIN {lista.add("string_literal");};bin_op 		: and_logico (OR and_logico)* {lista.add("bin_op");};and_logico 	: comparacion (AND comparacion)* {lista.add("and_logico");};comparacion : suma (MENORQUE suma | MAYORQUE suma | MENORIGUAL suma | MAYORIGUAL suma)* {lista.add("comparacion");};suma 		: multiplica (MAS multiplica | MENOS multiplica)* {lista.add("multiplica (MAS multiplica | MENOS multiplica)*");};multiplica 	: expr_prim (MULTIPLICACION expr_prim | DIVISION expr_prim | MODULO expr_prim)* {lista.add("expr_prim (MULTIPLICACION expr_prim | DIVISION expr_prim | MODULO expr_prim)*");};expr_prim 	: MENOS expr | NEGADO expr | PARENTESISD expr PARENTESISI {lista.add("MENOS expr | NEGADO expr | PARENTESISD expr PARENTESISI");};literal 	: int_literal | char_literal | bool_literal {lista.add("int_literal | char_literal | bool_literal");};int_literal : NUMEROS {lista.add("NUMEROS");};char_literal: CARACTER {lista.add("CARACTER");};bool_literal: TRUE | FALSE {lista.add("TRUE | FALSE");};