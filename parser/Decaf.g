parser grammar Decaf;options {    tokenVocab=Decaf;}@header {package compiler.parser;}program		:	CLASS PROGRAM LLAVEI field_decl* method_decl* LLAVED;field_decl	:	type decl_list (COMA decl_list)* PUNTOCOMA;decl_list	:	ID | ID CORCHETEI int_literal CORCHETED;int_literal :	NUMEROS;method_decl	:	(type | VOID) ID PARENTESISI (type ID (COMA type ID)*)? PARENTESISD block;var_decl 	: 	type ID (COMA ID)* PUNTOCOMA;type 		: 	INT | BOOLEAN ;statement : location assign_op expr PUNTOCOMA | method_call PUNTOCOMA | IF PARENTESISI expr PARENTESISD block (ELSE block)? | FOR ID IGUAL expr COMA expr block | RETURN expr? PUNTOCOMA | BREAK PUNTOCOMA | CONTINUE PUNTOCOMA | block;	block 		: 	LLAVEI var_decl* statement* LLAVED;assign_op 	: 	IGUAL | MENOSIGUAL | MASIGUAL;method_call : 	method_name PARENTESISI (expr (COMA expr)*)? PARENTESISD | CALLOUT PARENTESISI string_literal (COMA callout_arg)* PARENTESISD;method_name : ID;callout_arg : expr | string_literal;string_literal : CHAIN;location 	: ID | ID CORCHETEI expr CORCHETED;expr 		: location | method_call | literal | bin_op;bin_op 		: and_logico (OR and_logico)*;and_logico 	: comparacion (AND comparacion)*;comparacion : suma (MENORQUE suma | MAYORQUE suma | MENORIGUAL suma | MAYORIGUAL suma)*;suma 		: multiplica (MAS multiplica | MENOS multiplica)*;multiplica 	: expr_prim (MULTIPLICACION expr_prim | DIVISION expr_prim | MODULO expr_prim)*;expr_prim 	: MENOS expr | NEGADO expr | PARENTESISD expr PARENTESISI;