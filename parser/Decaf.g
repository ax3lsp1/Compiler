parser grammar Decaf;options {    tokenVocab=DecafLexer;}@header {package compiler.parser;import java.util.concurrent.ConcurrentLinkedQueue;}@members {ConcurrentLinkedQueue<String> lista = new ConcurrentLinkedQueue<String>();	public void Imprimir(String elementos){			System.out.println(elementos);	}		public ConcurrentLinkedQueue<String> getOutPut() {        return lista;    }		}program     :	CLASS PROGRAM LLAVEI field_decl* method_decl* LLAVED {lista.add("Program Declaration");};field_decl	:	type (decl_list) (COMA (decl_list))* PUNTOCOMA {lista.add("field_decl");}; decl_list	:	ID | ID CORCHETEI int_literal CORCHETED {lista.add("decl_list");};method_decl	:	method_type ID PARENTESISI par_dec? PARENTESISD block {lista.add("method_decl");};------------------------method_type :   type {lista.add("method_type: type");}; par_dec : (type ID) ((COMA (type ID))*);block 		: 	LLAVEI block_decl* statement* LLAVED {lista.add("block");};block_decl	:	var_decl | statement;var_decl 	: 	type ID (COMA ID)* PUNTOCOMA;type 		: 	INT {lista.add("type int");} | BOOLEAN {lista.add("type boolean");} | VOID {lista.add("method_type: VOID");};statement : location assign_op expr PUNTOCOMA {lista.add("statement asign");} 			| method_call PUNTOCOMA {lista.add("statement method_call");} 			| IF PARENTESISI expr PARENTESISD block (ELSE block)? {lista.add("statement if block");} 			| FOR ID IGUAL expr COMA expr block {lista.add("statement for block");} 			| RETURN expr? PUNTOCOMA {lista.add("statement return");} 			| BREAK PUNTOCOMA {lista.add("statement break");} 			| CONTINUE PUNTOCOMA {lista.add("statement continue");}			| block {lista.add("statement block");};	assign_op 	: 	IGUAL {lista.add("assign_op =");}				| MENOSIGUAL {lista.add("assign_op +=");}				| MASIGUAL {lista.add("assign_op -=");};method_call : 	method_name PARENTESISI (expr (COMA expr)*)? PARENTESISD {lista.add("method_call name");}				| CALLOUT PARENTESISI string_literal (COMA callout_arg)* PARENTESISD {lista.add("method_call callout");};method_name : 	ID {lista.add("method_name");};location 	: 	ID {lista.add("variable id");} 				| ID CORCHETEI expr CORCHETED {lista.add("id arreglo");};expr 		: 	NEGADO  bin_op				| MENOS bin_op 				| bin_op;bin_op 		: and_logico (OR and_logico)*;and_logico 	: comparacion_menor (AND comparacion_menor)*;comparacion_menor : comparacion_mayor (MENORQUE comparacion_mayor)*;comparacion_mayor : comparacion_menorigual (MAYORQUE comparacion_menorigual)*;comparacion_menorigual : comparacion_mayorigual (MENORIGUAL comparacion_mayorigual)*;comparacion_mayorigual : comparacion_igual (MAYORIGUAL comparacion_igual)*;comparacion_igual : comparacion_noesigual (IGUAL comparacion_noesigual)*;comparacion_noesigual : subplus_operations (NOESIGUAL subplus_operations)*;subplus_operations : muldiv_operations (MAS muldiv_operations | MENOS muldiv_operations)*;muldiv_operations : expresion (MULTIPLICACION expresion | DIVISION expresion)*;expresion : location | method_call | literal | PARENTESISI expr PARENTESISD;callout_arg : expr  {lista.add("callout_arg expr");} | string_literal {lista.add("callout_arg literal");};literal 	: NUMEROS {lista.add("numero");} | CARACTER {lista.add("caracter");} | bool_literal {lista.add("boolean");} | HEX {lista.add("hexadecimal");};int_literal : NUMEROS {lista.add("numero");} | BOOLEAN {lista.add("boolean");};bool_literal: TRUE {lista.add("TRUE");} | FALSE {lista.add("FALSE");};string_literal : CHAIN {lista.add("string_literal");};