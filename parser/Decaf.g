parser grammar Decaf;options {    tokenVocab=Decaf;}@header {package compiler.parser;import java.util.concurrent.ConcurrentLinkedQueue;}@members {ConcurrentLinkedQueue<String> lista = new ConcurrentLinkedQueue<String>();	public void addCLQ(String elementos){			lista.add(elementos);	}		public ConcurrentLinkedQueue<String> getOutPut() {        return lista;    }		}program     :	CLASS PROGRAM LLAVEI field_decl* method_decl* LLAVED {addCLQ("Program Declaration");};field_decl	:	type decl_list (COMA decl_list)* PUNTOCOMA { addCLQ("field_decl");}; decl_list	:	ID | ID CORCHETEI int_literal CORCHETED {addCLQ("decl_list");};method_decl	:	(type | VOID) ID PARENTESISI (type ID (COMA type ID)*)? PARENTESISD block {addCLQ("method_decl");};var_decl 	: 	type ID (COMA ID)* PUNTOCOMA {addCLQ("var_decl");};type 		: 	INT | BOOLEAN {addCLQ("type");};statement : location assign_op expr PUNTOCOMA | method_call PUNTOCOMA | IF PARENTESISI expr PARENTESISD block (ELSE block)? | FOR ID IGUAL expr COMA expr block | RETURN expr? PUNTOCOMA | BREAK PUNTOCOMA | CONTINUE PUNTOCOMA | block {addCLQ("Statement");};	block 		: 	LLAVEI var_decl* statement* LLAVED {addCLQ("block");};assign_op 	: 	IGUAL | MENOSIGUAL | MASIGUAL {addCLQ("assign_op");};method_call : 	method_name PARENTESISI (expr (COMA expr)*)? PARENTESISD | CALLOUT PARENTESISI string_literal (COMA callout_arg)* PARENTESISD {addCLQ("method_call");};method_name : ID {addCLQ("method_name");};callout_arg : expr | string_literal {addCLQ("callout_arg");};string_literal : CHAIN {addCLQ("string_literal");};location 	: ID | ID CORCHETEI expr CORCHETED {addCLQ("location");};expr 		: location | method_call | literal | bin_op {addCLQ("expr");};bin_op 		: and_logico (OR and_logico)* {addCLQ("bin_op");};and_logico 	: comparacion (AND comparacion)* {addCLQ("and_logico");};comparacion : suma (MENORQUE suma | MAYORQUE suma | MENORIGUAL suma | MAYORIGUAL suma)* {addCLQ("comparacion");};suma 		: multiplica (MAS multiplica | MENOS multiplica)* {addCLQ("multiplica (MAS multiplica | MENOS multiplica)*");};multiplica 	: expr_prim (MULTIPLICACION expr_prim | DIVISION expr_prim | MODULO expr_prim)* {addCLQ("expr_prim (MULTIPLICACION expr_prim | DIVISION expr_prim | MODULO expr_prim)*");};expr_prim 	: MENOS expr | NEGADO expr | PARENTESISD expr PARENTESISI {addCLQ("MENOS expr | NEGADO expr | PARENTESISD expr PARENTESISI");};literal 	: int_literal | char_literal | bool_literal {addCLQ("int_literal | char_literal | bool_literal");};int_literal : NUMEROS {addCLQ("NUMEROS");};char_literal: CARACTER {addCLQ("CARACTER");};bool_literal: TRUE | FALSE {addCLQ("TRUE | FALSE");};